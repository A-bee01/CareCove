{"version":3,"file":"data-BXX_a5-m.js","sources":["../../../../node_modules/nuxt/dist/app/compat/interval.js","../../../../data_providers/data.js"],"sourcesContent":["import { createError } from \"../composables/error.js\";\nconst intervalError = \"[nuxt] `setInterval` should not be used on the server. Consider wrapping it with an `onNuxtReady`, `onBeforeMount` or `onMounted` lifecycle hook, or ensure you only call it in the browser by checking `import.meta.client`.\";\nexport const setInterval = import.meta.client ? window.setInterval : () => {\n  if (import.meta.dev) {\n    throw createError({\n      statusCode: 500,\n      message: intervalError\n    });\n  }\n  console.error(intervalError);\n};\n","import { reactive, watch, onMounted } from 'vue';\nimport { Close, Order, Rfq, TbdexHttpClient } from '@tbdex/http-client';\nimport { DidDht } from '@web5/dids';\nimport { Jwt, PresentationExchange } from '@web5/credentials';\nimport { getAuth, onAuthStateChanged } from 'firebase/auth';\nimport { doc, getDoc, setDoc } from 'firebase/firestore';\nimport { db } from '~/src/firebaseConfig'; // Firestore instance\nimport { useRouter } from 'vue-router';\n\n// TODO 1: Choose Mock PFI DIDs using info about services they provide.\nconst mockProviderDids = {\n  aquafinance_capital: {\n    uri: 'did:dht:3fkz5ssfxbriwks3iy5nwys3q5kyx64ettp9wfn1yfekfkiguj1y',\n    name: 'AquaFinance Capital',\n    description: 'Provides exchanges with the Ghanaian Cedis: GHS to USDC, GHS to KES'\n  },\n  flowback_financial: {\n    uri: 'did:dht:zkp5gbsqgzn69b3y5dtt5nnpjtdq6sxyukpzo68npsf79bmtb9zy',\n    name: 'Flowback Financial',\n    description: 'Offers international rates with various currencies - USD to GBP, GBP to CAD.'\n  },\n  vertex_liquid_assets: {\n    uri: 'did:dht:enwguxo8uzqexq14xupe4o9ymxw3nzeb9uug5ijkj9rhfbf1oy5y',\n    name: 'Vertex Liquid Assets',\n    description: 'Offers currency exchanges between African currencies - MAD to EGP, GHS to NGN.'\n  },\n  titanium_trust: {\n    uri: 'did:dht:ozn5c51ruo7z63u1h748ug7rw5p1mq3853ytrd5gatu9a8mm8f1o',\n    name: 'Titanium Trust',\n    description: 'Provides offerings to exchange USD to African currencies - USD to GHS, USD to KES.'\n  }\n};\n\nexport const useStore = () => {\n  const state = reactive({\n    balance: 1000,\n    transactions: [],\n    transactionsLoading: true,\n    pfiAllowlist: Object.keys(mockProviderDids).map(key => ({\n      pfiUri: mockProviderDids[key].uri,\n      pfiName: mockProviderDids[key].name,\n      pfiDescription: mockProviderDids[key].description,\n    })),\n    selectedTransaction: null,\n    offering: null,\n    payinCurrencies: [],\n    payoutCurrencies: [],\n    offerings: [],\n    customerDid: null,\n    customerCredentials: [],\n  });\n\n  // Check if window object is available (client-side)\n  if (typeof window !== 'undefined') {\n    const storedBalance = localStorage.getItem('walletBalance');\n    state.balance = parseFloat(storedBalance) || 10000;\n  }\n\n  const loadBalance = async () => {\n    try {\n      // Get the currently authenticated user\n      const auth = getAuth();\n      const user = auth.currentUser;\n\n      if (!user) {\n        // Redirect to login page if not authenticated\n        console.log('User is not authenticated, redirecting to login...');\n        router.push('/login'); // Adjust the URL as per your routing\n        return;\n      }\n\n      // Fetch balance from Firestore\n      const userDocRef = doc(db, 'donors', user.email); // Assuming 'users' collection with documents named after user IDs\n      const userDoc = await getDoc(userDocRef);\n\n      if (userDoc.exists()) {\n        const data = userDoc.data();\n        if (data.balance) {\n          // Load balance from Firestore\n          state.balance = data.balance;\n          console.log('Balance loaded from Firestore:', state.balance);\n\n          // Optionally, save balance to localStorage for offline access\n          localStorage.setItem('walletBalance', state.balance.toString());\n        } else {\n          // Set default balance if none is found\n          state.balance = 10000;\n          console.log('No balance found, setting to default (1000)');\n        }\n      } else {\n        console.log('User document does not exist in Firestore.');\n        state.balance = 10000; // Set default balance if user doc doesn't exist\n        await setDoc(userDocRef, { balance: state.balance }); // Save default balance to Firestore\n      }\n    } catch (error) {\n      console.error('Error loading balance from Firestore:', error);\n    }\n  };\n\n  const auth = getAuth();\n  const router = useRouter();\n\n  // Redirect to login if user is not authenticated\n  onAuthStateChanged(auth, (user) => {\n    if (!user) {\n      router.push('/login'); // Redirect to login if not authenticated\n    }\n  });\n\n  const fetchOfferings = async () => {\n    try {\n      const allOfferings = []\n      for (const pfi of state.pfiAllowlist) {\n        const pfiUri = pfi.pfiUri\n        // TODO 2: Fetch offerings from PFIs\n        const offerings = await TbdexHttpClient.getOfferings({\n          pfiDid: pfiUri\n        })\n        allOfferings.push(...offerings)\n      }\n\n      state.offerings = allOfferings\n      updateCurrencies();\n    } catch (error) {\n      console.error('Failed to fetch offerings:', error);\n    }\n  };\n\n  const createExchange = async (offering, amount, payoutPaymentDetails) => {\n    // TODO 3: Choose only needed credentials to present using PresentationExchange.selectCredentials\n    const selectedCredentials = PresentationExchange.selectCredentials({\n      vcJwts: state.customerCredentials,\n      presentationDefinition: offering.data.requiredClaims,\n    })\n\n    // TODO 4: Create RFQ message to Request for a Quote\n    const rfq = Rfq.create({\n      metadata: {\n        from: state.customerDid.uri,\n        to: offering.metadata.from,\n        protocol: '1.0'\n      },\n      data: {\n        offeringId: offering.id,\n        payin: {\n          amount: amount.toString(),\n          kind: offering.data.payin.methods[0].kind,\n          paymentDetails: {}\n        },\n        payout: {\n          kind: offering.data.payout.methods[0].kind,\n          paymentDetails: payoutPaymentDetails\n        },\n        claims: selectedCredentials\n      },\n    })\n\n    try {\n      // TODO 5: Verify offering requirements with RFQ - rfq.verifyOfferingRequirements(offering)\n      rfq.verifyOfferingRequirements(offering)\n    } catch (e) {\n      // handle failed verification\n      console.log('Offering requirements not met', e)\n    }\n\n    // TODO 6: Sign RFQ message\n    await rfq.sign(state.customerDid)\n\n    console.log('RFQ:', rfq)\n\n    try {\n      // TODO 7: Submit RFQ message to the PFI .createExchange(rfq)\n      await TbdexHttpClient.createExchange(rfq)\n    }\n    catch (error) {\n      console.error('Failed to create exchange:', error);\n    }\n  }\n\n  const fetchExchanges = async (pfiUri) => {\n    try {\n      // TODO 8: get exchanges from the PFI\n      const exchanges = await TbdexHttpClient.getExchanges({\n        pfiDid: pfiUri,\n        did: state.customerDid\n      });\n\n      const mappedExchanges = formatMessages(exchanges)\n      return mappedExchanges\n    } catch (error) {\n      console.error('Failed to fetch exchanges:', error);\n    }\n  }\n\n  const addClose = async (exchangeId, pfiUri, reason) => {\n    // TODO 9: Create Close message, sign it, and submit it to the PFI\n    const close = Close.create({\n      metadata: {\n        from: state.customerDid.uri,\n        to: pfiUri,\n        exchangeId,\n      },\n      data: {\n        reason\n      }\n    })\n\n    await close.sign(state.customerDid)\n    try {\n      // send Close message\n      await TbdexHttpClient.submitClose(close)\n    }\n    catch (error) {\n      console.error('Failed to close exchange:', error);\n    }\n  }\n\n  const addOrder = async (exchangeId, pfiUri) => {\n    // TODO 10: Create Order message, sign it, and submit it to the PFI\n    const order = Order.create({\n      metadata: {\n        from: state.customerDid.uri,\n        to: pfiUri,\n        exchangeId\n      }\n    })\n\n    await order.sign(state.customerDid)\n    try {\n      // Send order message\n      return await TbdexHttpClient.submitOrder(order)\n    } catch (error) {\n      console.error('Failed to submit order:', error);\n    }\n  };\n\n  const pollExchanges = () => {\n    const fetchAllExchanges = async () => {\n      console.log('Polling exchanges again...');\n      if (!state.customerDid) return\n      const allExchanges = []\n      try {\n        for (const pfi of state.pfiAllowlist) {\n          const exchanges = await fetchExchanges(pfi.pfiUri);\n          allExchanges.push(...exchanges)\n        }\n        console.log('All exchanges:', allExchanges);\n        updateExchanges(allExchanges.reverse());\n        state.transactionsLoading = false;\n      } catch (error) {\n        console.error('Failed to fetch exchanges:', error);\n      }\n    };\n\n    // Run the function immediately\n    fetchAllExchanges();\n\n    // Set up the interval to run the function periodically\n    setInterval(fetchAllExchanges, 5000); // Poll every 5 seconds\n  };\n\n  const initializeDid = async () => {\n    try {\n      const user = auth.currentUser;\n      if (!user) {\n        console.error('No user is logged in');\n        router.push('/login');\n        return;\n      }\n\n      const email = user.email;\n      const donorRef = doc(db, 'donors', email);\n      const donorDoc = await getDoc(donorRef);\n\n      if (donorDoc.exists()) {\n        // If a DID is stored in Firestore, retrieve it\n        const storedDid = donorDoc.data().did;\n        state.customerDid = await DidDht.import({ portableDid: JSON.parse(storedDid) });\n\n        // Load stored credentials if they exist\n        const storedCredentials = donorDoc.data().credentials;\n        if (storedCredentials) {\n          state.customerCredentials = JSON.parse(storedCredentials);\n          localStorage.setItem('customerCredentials', JSON.stringify(state.customerCredentials));\n        }\n\n      } else {\n        // If no DID is stored, create one and save it to Firestore\n        state.customerDid = await DidDht.create({ options: { publish: true } });\n        const exportedDid = await state.customerDid.export();\n\n        // Save the DID and initial credentials to Firestore\n        await setDoc(donorRef, {\n          email: email,\n          did: JSON.stringify(exportedDid),\n          credentials: JSON.stringify(state.customerCredentials), // Save empty credentials initially\n          createdAt: new Date(),\n        });\n\n        //Save to localStorage as a fallback\n        localStorage.setItem('customerDid', JSON.stringify(exportedDid));\n      }\n    } catch (error) {\n      console.error('Failed to initialize DID:', error);\n    }\n  };\n\n  const formatMessages = (exchanges) => {\n    const formattedMessages = exchanges.map(exchange => {\n      const latestMessage = exchange[exchange.length - 1]\n      const rfqMessage = exchange.find(message => message.kind === 'rfq')\n      const quoteMessage = exchange.find(message => message.kind === 'quote')\n      // console.log('quote', quoteMessage)\n      const status = generateExchangeStatusValues(latestMessage)\n      const fee = quoteMessage?.data['payin']?.['fee']\n      const payinAmount = quoteMessage?.data['payin']?.['amount']\n      const payoutPaymentDetails = rfqMessage.privateData?.payout.paymentDetails\n      return {\n        id: latestMessage.metadata.exchangeId,\n        payinAmount: (fee ? Number(payinAmount) + Number(fee) : Number(payinAmount)).toString() || rfqMessage.data['payinAmount'],\n        payinCurrency: quoteMessage.data['payin']?.['currencyCode'] ?? null,\n        payoutAmount: quoteMessage?.data['payout']?.['amount'] ?? null,\n        payoutCurrency: quoteMessage.data['payout']?.['currencyCode'],\n        status,\n        createdTime: rfqMessage.createdAt,\n        ...latestMessage.kind === 'quote' && { expirationTime: quoteMessage.data['expiresAt'] ?? null },\n        from: 'You',\n        to: payoutPaymentDetails?.address || payoutPaymentDetails?.accountNumber + ', ' + payoutPaymentDetails?.bankName || payoutPaymentDetails?.phoneNumber + ', ' + payoutPaymentDetails?.networkProvider || 'Unknown',\n        pfiDid: rfqMessage.metadata.to\n      }\n    })\n\n    return formattedMessages;\n  }\n\n  const loadCredentials = async () => {\n    try {\n      // Get the currently authenticated user\n      const auth = getAuth();\n      const user = auth.currentUser;\n\n      if (!user) {\n        console.error('No user is logged in');\n        router.push('/login');\n        return;\n      }\n\n      // Fetch credentials from Firestore\n      const userDocRef = doc(db, 'users', user.uid); // Assuming 'users' collection with documents named after user IDs\n      const userDoc = await getDoc(userDocRef);\n\n      if (userDoc.exists()) {\n        const data = userDoc.data();\n        if (data.credentials) {\n          // Load credentials from Firestore\n          state.customerCredentials = data.credentials;\n          console.log('Credentials loaded from Firestore:', state.customerCredentials);\n\n          // Optionally, save credentials to localStorage for offline access\n          localStorage.setItem('customerCredentials', JSON.stringify(state.customerCredentials));\n        } else {\n          console.log('No credentials found in Firestore.');\n        }\n      } else {\n        console.log('User document does not exist in Firestore.');\n      }\n    } catch (error) {\n      console.error('Error loading credentials from Firestore:', error);\n    }\n  };\n\n\n  const addCredential = async (credential) => {\n    state.customerCredentials.push(credential);\n    localStorage.setItem('customerCredentials', JSON.stringify(state.customerCredentials));\n    const user = auth.currentUser;\n    if (user) {\n      const donorRef = doc(db, 'donors', user.email);\n      // Update Firestore with new credentials\n      await setDoc(donorRef, {\n        credentials: JSON.stringify(state.customerCredentials)\n      }, { merge: true });\n    }\n\n  };\n\n  const renderCredential = (credentialJwt) => {\n    const vc = Jwt.parse({ jwt: credentialJwt }).decoded.payload['vc']\n    return {\n      title: vc.type[vc.type.length - 1].replace(/(?<!^)(?<![A-Z])[A-Z](?=[a-z])/g, ' $&'), // get the last credential type in the array and format it with spaces\n      name: vc.credentialSubject['name'],\n      countryCode: vc.credentialSubject['countryOfResidence'],\n      issuanceDate: new Date(vc.issuanceDate).toLocaleDateString(undefined, { dateStyle: 'medium' }),\n    }\n  }\n\n  // Watch the balance and persist it to localStorage on change\n  watch(() => state.balance, async (newBalance) => {\n    try {\n      const auth = getAuth();\n      const user = auth.currentUser;\n\n      if (!user) {\n        console.log('User is not authenticated, redirecting to login...');\n        router.push('/login'); // Adjust the URL as per your routing\n        return;\n      }\n\n      // Persist balance to Firestore\n      const userDocRef = doc(db, 'users', user.uid);\n      await setDoc(userDocRef, { balance: newBalance }, { merge: true }); // Merge to avoid overwriting other fields\n      console.log('Balance updated in Firestore:', newBalance);\n\n      // Optionally, persist to localStorage for offline access\n      if (typeof window !== 'undefined') {\n        localStorage.setItem('walletBalance', newBalance.toString());\n      }\n    } catch (error) {\n      console.error('Error updating balance in Firestore:', error);\n    }\n  });\n\n\n  const generateExchangeStatusValues = (exchangeMessage) => {\n    if (exchangeMessage instanceof Close) {\n      if (exchangeMessage.data.reason.toLowerCase().includes('complete') || exchangeMessage.data.reason.toLowerCase().includes('success')) {\n        return 'completed'\n      } else if (exchangeMessage.data.reason.toLowerCase().includes('expired')) {\n        return exchangeMessage.data.reason.toLowerCase()\n      } else if (exchangeMessage.data.reason.toLowerCase().includes('cancelled')) {\n        return 'cancelled'\n      } else {\n        return 'failed'\n      }\n    }\n    return exchangeMessage.kind\n  }\n\n  const renderOrderStatus = (exchange) => {\n    const status = generateExchangeStatusValues(exchange)\n    switch (status) {\n      case 'rfq':\n        return 'Requested'\n      case 'quote':\n        return 'Quoted'\n      case 'order':\n      case 'orderstatus':\n        return 'Pending'\n      case 'completed':\n        return 'Completed'\n      case 'expired':\n        return 'Expired'\n      case 'cancelled':\n        return 'Cancelled'\n      case 'failed':\n        return 'Failed'\n      default:\n        return status\n    }\n  }\n\n  const selectTransaction = (transaction) => {\n    state.selectedTransaction = transaction;\n  };\n\n  const setOffering = (offering) => {\n    state.offering = offering;\n  };\n\n  const deductAmount = async (amount) => {\n    const numericAmount = parseFloat(amount);\n    if (!isNaN(numericAmount) && numericAmount > 0) {\n      state.balance -= numericAmount;\n\n      try {\n        const auth = getAuth();\n        const user = auth.currentUser;\n\n        if (!user) {\n          console.log('User is not authenticated, redirecting to login...');\n          router.push('/login'); // Adjust the URL as per your routing\n          return;\n        }\n\n        // Persist balance to Firestore\n        const userDocRef = doc(db, 'donors', user.email);\n        await setDoc(userDocRef, { balance: state.balance }, { merge: true });\n        console.log('Balance deducted and updated in Firestore:', state.balance);\n\n        // Optionally, persist to localStorage for offline access\n        localStorage.setItem('walletBalance', state.balance.toString());\n      } catch (error) {\n        console.error('Error deducting balance in Firestore:', error);\n      }\n    }\n  };\n\n\n  const formatAmount = (amount) => {\n    if (Math.abs(amount) >= 1) {\n      return amount.toFixed(2);\n    }\n\n    const precision = Math.abs(amount) >= 0.01 ? 4 : 6;\n    return parseFloat(amount.toFixed(precision)).toString();\n  };\n\n\n  const getOfferingById = (offeringId) => {\n    const selectedOffering = state.offerings.find(offering => offering.id === offeringId);\n    console.log('Selected offering:', selectedOffering);\n    return selectedOffering;\n  }\n\n  const updateCurrencies = () => {\n    const payinCurrencies = new Set();\n    const payoutCurrencies = new Set();\n\n    state.offerings.forEach(offering => {\n      payinCurrencies.add(offering.data.payin.currencyCode);\n      payoutCurrencies.add(offering.data.payout.currencyCode);\n    });\n\n    state.payinCurrencies = Array.from(payinCurrencies);\n    state.payoutCurrencies = Array.from(payoutCurrencies);\n  };\n\n  const filterOfferings = (payinCurrency, payoutCurrency) => {\n    return state.offerings.filter(offering =>\n      offering.data.payin.currencyCode === payinCurrency &&\n      offering.data.payout.currencyCode === payoutCurrency\n    );\n  };\n\n  const satisfiesOfferingRequirements = (offering, credentials) => {\n    if (credentials.length === 0 || !offering.data.requiredClaims) {\n      return false;\n    }\n\n    try {\n      // Validate customer's VCs against the offering's presentation definition\n      PresentationExchange.satisfiesPresentationDefinition({\n        vcJwts: credentials,\n        presentationDefinition: offering.data.requiredClaims,\n      })\n      return true\n    } catch (e) {\n      return false\n    }\n  }\n\n  const updateExchanges = (newTransactions) => {\n    const existingExchangeIds = state.transactions.map(tx => tx.id);\n    const updatedExchanges = [...state.transactions];\n\n    newTransactions.forEach(newTx => {\n      const existingTxIndex = updatedExchanges.findIndex(tx => tx.id === newTx.id);\n      if (existingTxIndex > -1) {\n        // Update the existing transaction\n        updatedExchanges[existingTxIndex] = newTx;\n      } else {\n        // Add the new transaction\n        updatedExchanges.push(newTx);\n      }\n    });\n\n    // Sort the transactions if needed\n    // updatedTransactions.sort((a, b) => new Date(b.createdTime) - new Date(a.createdTime));\n\n    // Update the state with the new transactions\n    state.transactions = updatedExchanges;\n  };\n\n  // Automatically fetch offerings on load\n  onMounted(async () => {\n    console.log('Fetching offerings...');\n    fetchOfferings();\n    console.log('Initializing DID...');\n    await initializeDid();\n    console.log('Loading credentials...');\n    loadCredentials();\n    console.log('Loading balance...');\n    await loadBalance();\n  });\n\n  return { state, selectTransaction, setOffering, deductAmount, formatAmount, fetchOfferings, filterOfferings, satisfiesOfferingRequirements, addCredential, renderCredential, createExchange, fetchExchanges, renderOrderStatus, addOrder, addClose, getOfferingById, pollExchanges };\n\n};\n"],"names":["auth"],"mappings":";;;;;;;;;AACA,MAAM,gBAAgB;AACf,MAAM,cAAwD,MAAM;AAOzE,UAAQ,MAAM,aAAa;AAC7B;ACAA,MAAM,mBAAmB;AAAA,EACvB,qBAAqB;AAAA,IACnB,KAAK;AAAA,IACL,MAAM;AAAA,IACN,aAAa;AAAA,EACf;AAAA,EACA,oBAAoB;AAAA,IAClB,KAAK;AAAA,IACL,MAAM;AAAA,IACN,aAAa;AAAA,EACf;AAAA,EACA,sBAAsB;AAAA,IACpB,KAAK;AAAA,IACL,MAAM;AAAA,IACN,aAAa;AAAA,EACf;AAAA,EACA,gBAAgB;AAAA,IACd,KAAK;AAAA,IACL,MAAM;AAAA,IACN,aAAa;AAAA,EACf;AACF;AAEO,MAAM,WAAW,MAAM;AAC5B,QAAM,QAAQ,SAAS;AAAA,IACrB,SAAS;AAAA,IACT,cAAc,CAAC;AAAA,IACf,qBAAqB;AAAA,IACrB,cAAc,OAAO,KAAK,gBAAgB,EAAE,IAAI,CAAQ,SAAA;AAAA,MACtD,QAAQ,iBAAiB,GAAG,EAAE;AAAA,MAC9B,SAAS,iBAAiB,GAAG,EAAE;AAAA,MAC/B,gBAAgB,iBAAiB,GAAG,EAAE;AAAA,IAAA,EACtC;AAAA,IACF,qBAAqB;AAAA,IACrB,UAAU;AAAA,IACV,iBAAiB,CAAC;AAAA,IAClB,kBAAkB,CAAC;AAAA,IACnB,WAAW,CAAC;AAAA,IACZ,aAAa;AAAA,IACb,qBAAqB,CAAC;AAAA,EAAA,CACvB;AAiDD,QAAM,OAAO;AACb,QAAM,SAAS;AAGI,qBAAA,MAAM,CAAC,SAAS;AACjC,QAAI,CAAC,MAAM;AACT,aAAO,KAAK,QAAQ;AAAA,IACtB;AAAA,EAAA,CACD;AAED,QAAM,iBAAiB,YAAY;AAC7B,QAAA;AACF,YAAM,eAAe,CAAA;AACV,iBAAA,OAAO,MAAM,cAAc;AACpC,cAAM,SAAS,IAAI;AAEb,cAAA,YAAY,MAAM,gBAAgB,aAAa;AAAA,UACnD,QAAQ;AAAA,QAAA,CACT;AACY,qBAAA,KAAK,GAAG,SAAS;AAAA,MAChC;AAEA,YAAM,YAAY;AACD;aACV,OAAO;AACN,cAAA,MAAM,8BAA8B,KAAK;AAAA,IACnD;AAAA,EAAA;AAGF,QAAM,iBAAiB,OAAO,UAAU,QAAQ,yBAAyB;AAEjE,UAAA,sBAAsB,qBAAqB,kBAAkB;AAAA,MACjE,QAAQ,MAAM;AAAA,MACd,wBAAwB,SAAS,KAAK;AAAA,IAAA,CACvC;AAGK,UAAA,MAAM,IAAI,OAAO;AAAA,MACrB,UAAU;AAAA,QACR,MAAM,MAAM,YAAY;AAAA,QACxB,IAAI,SAAS,SAAS;AAAA,QACtB,UAAU;AAAA,MACZ;AAAA,MACA,MAAM;AAAA,QACJ,YAAY,SAAS;AAAA,QACrB,OAAO;AAAA,UACL,QAAQ,OAAO,SAAS;AAAA,UACxB,MAAM,SAAS,KAAK,MAAM,QAAQ,CAAC,EAAE;AAAA,UACrC,gBAAgB,CAAC;AAAA,QACnB;AAAA,QACA,QAAQ;AAAA,UACN,MAAM,SAAS,KAAK,OAAO,QAAQ,CAAC,EAAE;AAAA,UACtC,gBAAgB;AAAA,QAClB;AAAA,QACA,QAAQ;AAAA,MACV;AAAA,IAAA,CACD;AAEG,QAAA;AAEF,UAAI,2BAA2B,QAAQ;AAAA,aAChC,GAAG;AAEF,cAAA,IAAI,iCAAiC,CAAC;AAAA,IAChD;AAGM,UAAA,IAAI,KAAK,MAAM,WAAW;AAExB,YAAA,IAAI,QAAQ,GAAG;AAEnB,QAAA;AAEI,YAAA,gBAAgB,eAAe,GAAG;AAAA,aAEnC,OAAO;AACJ,cAAA,MAAM,8BAA8B,KAAK;AAAA,IACnD;AAAA,EAAA;AAGI,QAAA,iBAAiB,OAAO,WAAW;AACnC,QAAA;AAEI,YAAA,YAAY,MAAM,gBAAgB,aAAa;AAAA,QACnD,QAAQ;AAAA,QACR,KAAK,MAAM;AAAA,MAAA,CACZ;AAEK,YAAA,kBAAkB,eAAe,SAAS;AACzC,aAAA;AAAA,aACA,OAAO;AACN,cAAA,MAAM,8BAA8B,KAAK;AAAA,IACnD;AAAA,EAAA;AAGF,QAAM,WAAW,OAAO,YAAY,QAAQ,WAAW;AAE/C,UAAA,QAAQ,MAAM,OAAO;AAAA,MACzB,UAAU;AAAA,QACR,MAAM,MAAM,YAAY;AAAA,QACxB,IAAI;AAAA,QACJ;AAAA,MACF;AAAA,MACA,MAAM;AAAA,QACJ;AAAA,MACF;AAAA,IAAA,CACD;AAEK,UAAA,MAAM,KAAK,MAAM,WAAW;AAC9B,QAAA;AAEI,YAAA,gBAAgB,YAAY,KAAK;AAAA,aAElC,OAAO;AACJ,cAAA,MAAM,6BAA6B,KAAK;AAAA,IAClD;AAAA,EAAA;AAGI,QAAA,WAAW,OAAO,YAAY,WAAW;AAEvC,UAAA,QAAQ,MAAM,OAAO;AAAA,MACzB,UAAU;AAAA,QACR,MAAM,MAAM,YAAY;AAAA,QACxB,IAAI;AAAA,QACJ;AAAA,MACF;AAAA,IAAA,CACD;AAEK,UAAA,MAAM,KAAK,MAAM,WAAW;AAC9B,QAAA;AAEK,aAAA,MAAM,gBAAgB,YAAY,KAAK;AAAA,aACvC,OAAO;AACN,cAAA,MAAM,2BAA2B,KAAK;AAAA,IAChD;AAAA,EAAA;AAGF,QAAM,gBAAgB,MAAM;AAC1B,UAAM,oBAAoB,YAAY;AACpC,cAAQ,IAAI,4BAA4B;AACpC,UAAA,CAAC,MAAM,YAAa;AACxB,YAAM,eAAe,CAAA;AACjB,UAAA;AACS,mBAAA,OAAO,MAAM,cAAc;AACpC,gBAAM,YAAY,MAAM,eAAe,IAAI,MAAM;AACpC,uBAAA,KAAK,GAAG,SAAS;AAAA,QAChC;AACQ,gBAAA,IAAI,kBAAkB,YAAY;AAC1B,wBAAA,aAAa,SAAS;AACtC,cAAM,sBAAsB;AAAA,eACrB,OAAO;AACN,gBAAA,MAAM,8BAA8B,KAAK;AAAA,MACnD;AAAA,IAAA;AAIgB;AAGlB,gBAAmC;AAAA,EAAA;AAiD/B,QAAA,iBAAiB,CAAC,cAAc;AAC9B,UAAA,oBAAoB,UAAU,IAAI,CAAY,aAAA;;AAClD,YAAM,gBAAgB,SAAS,SAAS,SAAS,CAAC;AAClD,YAAM,aAAa,SAAS,KAAK,CAAW,YAAA,QAAQ,SAAS,KAAK;AAClE,YAAM,eAAe,SAAS,KAAK,CAAW,YAAA,QAAQ,SAAS,OAAO;AAEhE,YAAA,SAAS,6BAA6B,aAAa;AACzD,YAAM,OAAM,kDAAc,KAAK,aAAnB,mBAA8B;AAC1C,YAAM,eAAc,kDAAc,KAAK,aAAnB,mBAA8B;AAC5C,YAAA,wBAAuB,gBAAW,gBAAX,mBAAwB,OAAO;AACrD,aAAA;AAAA,QACL,IAAI,cAAc,SAAS;AAAA,QAC3B,cAAc,MAAM,OAAO,WAAW,IAAI,OAAO,GAAG,IAAI,OAAO,WAAW,GAAG,SAAA,KAAc,WAAW,KAAK,aAAa;AAAA,QACxH,iBAAe,kBAAa,KAAK,OAAO,MAAzB,mBAA6B,oBAAmB;AAAA,QAC/D,gBAAc,kDAAc,KAAK,cAAnB,mBAA+B,cAAa;AAAA,QAC1D,iBAAgB,kBAAa,KAAK,QAAQ,MAA1B,mBAA8B;AAAA,QAC9C;AAAA,QACA,aAAa,WAAW;AAAA,QACxB,GAAG,cAAc,SAAS,WAAW,EAAE,gBAAgB,aAAa,KAAK,WAAW,KAAK,KAAK;AAAA,QAC9F,MAAM;AAAA,QACN,KAAI,6DAAsB,aAAW,6DAAsB,iBAAgB,QAAO,6DAAsB,cAAY,6DAAsB,eAAc,QAAO,6DAAsB,oBAAmB;AAAA,QACxM,QAAQ,WAAW,SAAS;AAAA,MAAA;AAAA,IAC9B,CACD;AAEM,WAAA;AAAA,EAAA;AAwCH,QAAA,gBAAgB,OAAO,eAAe;AACpC,UAAA,oBAAoB,KAAK,UAAU;AACzC,iBAAa,QAAQ,uBAAuB,KAAK,UAAU,MAAM,mBAAmB,CAAC;AACrF,UAAM,OAAO,KAAK;AAClB,QAAI,MAAM;AACR,YAAM,WAAW,IAAI,IAAI,UAAU,KAAK,KAAK;AAE7C,YAAM,OAAO,UAAU;AAAA,QACrB,aAAa,KAAK,UAAU,MAAM,mBAAmB;AAAA,MAAA,GACpD,EAAE,OAAO,KAAA,CAAM;AAAA,IACpB;AAAA,EAAA;AAII,QAAA,mBAAmB,CAAC,kBAAkB;AACpC,UAAA,KAAK,IAAI,MAAM,EAAE,KAAK,cAAe,CAAA,EAAE,QAAQ,QAAQ,IAAI;AAC1D,WAAA;AAAA,MACL,OAAO,GAAG,KAAK,GAAG,KAAK,SAAS,CAAC,EAAE,QAAQ,WAAA,kCAAA,GAAA,GAAmC,KAAK;AAAA;AAAA,MACnF,MAAM,GAAG,kBAAkB,MAAM;AAAA,MACjC,aAAa,GAAG,kBAAkB,oBAAoB;AAAA,MACtD,cAAc,IAAI,KAAK,GAAG,YAAY,EAAE,mBAAmB,QAAW,EAAE,WAAW,UAAU;AAAA,IAAA;AAAA,EAC/F;AAIF,QAAM,MAAM,MAAM,SAAS,OAAO,eAAe;AAC3C,QAAA;AACF,YAAMA,QAAO;AACb,YAAM,OAAOA,MAAK;AAElB,UAAI,CAAC,MAAM;AACT,gBAAQ,IAAI,oDAAoD;AAChE,eAAO,KAAK,QAAQ;AACpB;AAAA,MACF;AAGA,YAAM,aAAa,IAAI,IAAI,SAAS,KAAK,GAAG;AACtC,YAAA,OAAO,YAAY,EAAE,SAAS,cAAc,EAAE,OAAO,KAAA,CAAM;AACzD,cAAA,IAAI,iCAAiC,UAAU;AAGvD,UAAI,MAA+B;AAAA,aAG5B,OAAO;AACN,cAAA,MAAM,wCAAwC,KAAK;AAAA,IAC7D;AAAA,EAAA,CACD;AAGK,QAAA,+BAA+B,CAAC,oBAAoB;AACxD,QAAI,2BAA2B,OAAO;AACpC,UAAI,gBAAgB,KAAK,OAAO,cAAc,SAAS,UAAU,KAAK,gBAAgB,KAAK,OAAO,YAAc,EAAA,SAAS,SAAS,GAAG;AAC5H,eAAA;AAAA,MAAA,WACE,gBAAgB,KAAK,OAAO,cAAc,SAAS,SAAS,GAAG;AACjE,eAAA,gBAAgB,KAAK,OAAO,YAAY;AAAA,MAAA,WACtC,gBAAgB,KAAK,OAAO,cAAc,SAAS,WAAW,GAAG;AACnE,eAAA;AAAA,MAAA,OACF;AACE,eAAA;AAAA,MACT;AAAA,IACF;AACA,WAAO,gBAAgB;AAAA,EAAA;AAGnB,QAAA,oBAAoB,CAAC,aAAa;AAChC,UAAA,SAAS,6BAA6B,QAAQ;AACpD,YAAQ,QAAQ;AAAA,MACd,KAAK;AACI,eAAA;AAAA,MACT,KAAK;AACI,eAAA;AAAA,MACT,KAAK;AAAA,MACL,KAAK;AACI,eAAA;AAAA,MACT,KAAK;AACI,eAAA;AAAA,MACT,KAAK;AACI,eAAA;AAAA,MACT,KAAK;AACI,eAAA;AAAA,MACT,KAAK;AACI,eAAA;AAAA,MACT;AACS,eAAA;AAAA,IACX;AAAA,EAAA;AAGI,QAAA,oBAAoB,CAAC,gBAAgB;AACzC,UAAM,sBAAsB;AAAA,EAAA;AAGxB,QAAA,cAAc,CAAC,aAAa;AAChC,UAAM,WAAW;AAAA,EAAA;AAGb,QAAA,eAAe,OAAO,WAAW;AAC/B,UAAA,gBAAgB,WAAW,MAAM;AACvC,QAAI,CAAC,MAAM,aAAa,KAAK,gBAAgB,GAAG;AAC9C,YAAM,WAAW;AAEb,UAAA;AACF,cAAMA,QAAO;AACb,cAAM,OAAOA,MAAK;AAElB,YAAI,CAAC,MAAM;AACT,kBAAQ,IAAI,oDAAoD;AAChE,iBAAO,KAAK,QAAQ;AACpB;AAAA,QACF;AAGA,cAAM,aAAa,IAAI,IAAI,UAAU,KAAK,KAAK;AACzC,cAAA,OAAO,YAAY,EAAE,SAAS,MAAM,WAAW,EAAE,OAAO,KAAA,CAAM;AAC5D,gBAAA,IAAI,8CAA8C,MAAM,OAAO;AAGvE,qBAAa,QAAQ,iBAAiB,MAAM,QAAQ,UAAU;AAAA,eACvD,OAAO;AACN,gBAAA,MAAM,yCAAyC,KAAK;AAAA,MAC9D;AAAA,IACF;AAAA,EAAA;AAII,QAAA,eAAe,CAAC,WAAW;AAC/B,QAAI,KAAK,IAAI,MAAM,KAAK,GAAG;AAClB,aAAA,OAAO,QAAQ,CAAC;AAAA,IACzB;AAEA,UAAM,YAAY,KAAK,IAAI,MAAM,KAAK,OAAO,IAAI;AACjD,WAAO,WAAW,OAAO,QAAQ,SAAS,CAAC,EAAE;EAAS;AAIlD,QAAA,kBAAkB,CAAC,eAAe;AACtC,UAAM,mBAAmB,MAAM,UAAU,KAAK,CAAY,aAAA,SAAS,OAAO,UAAU;AAC5E,YAAA,IAAI,sBAAsB,gBAAgB;AAC3C,WAAA;AAAA,EAAA;AAGT,QAAM,mBAAmB,MAAM;AACvB,UAAA,sCAAsB;AACtB,UAAA,uCAAuB;AAEvB,UAAA,UAAU,QAAQ,CAAY,aAAA;AAClC,sBAAgB,IAAI,SAAS,KAAK,MAAM,YAAY;AACpD,uBAAiB,IAAI,SAAS,KAAK,OAAO,YAAY;AAAA,IAAA,CACvD;AAEK,UAAA,kBAAkB,MAAM,KAAK,eAAe;AAC5C,UAAA,mBAAmB,MAAM,KAAK,gBAAgB;AAAA,EAAA;AAGhD,QAAA,kBAAkB,CAAC,eAAe,mBAAmB;AACzD,WAAO,MAAM,UAAU;AAAA,MAAO,CAAA,aAC5B,SAAS,KAAK,MAAM,iBAAiB,iBACrC,SAAS,KAAK,OAAO,iBAAiB;AAAA,IAAA;AAAA,EACxC;AAGI,QAAA,gCAAgC,CAAC,UAAU,gBAAgB;AAC/D,QAAI,YAAY,WAAW,KAAK,CAAC,SAAS,KAAK,gBAAgB;AACtD,aAAA;AAAA,IACT;AAEI,QAAA;AAEF,2BAAqB,gCAAgC;AAAA,QACnD,QAAQ;AAAA,QACR,wBAAwB,SAAS,KAAK;AAAA,MAAA,CACvC;AACM,aAAA;AAAA,aACA,GAAG;AACH,aAAA;AAAA,IACT;AAAA,EAAA;AAGI,QAAA,kBAAkB,CAAC,oBAAoB;AACf,UAAM,aAAa,IAAI,CAAA,OAAM,GAAG,EAAE;AAC9D,UAAM,mBAAmB,CAAC,GAAG,MAAM,YAAY;AAE/C,oBAAgB,QAAQ,CAAS,UAAA;AAC/B,YAAM,kBAAkB,iBAAiB,UAAU,QAAM,GAAG,OAAO,MAAM,EAAE;AAC3E,UAAI,kBAAkB,IAAI;AAExB,yBAAiB,eAAe,IAAI;AAAA,MAAA,OAC/B;AAEL,yBAAiB,KAAK,KAAK;AAAA,MAC7B;AAAA,IAAA,CACD;AAMD,UAAM,eAAe;AAAA,EAAA;AAevB,SAAO,EAAE,OAAO,mBAAmB,aAAa,cAAc,cAAc,gBAAgB,iBAAiB,+BAA+B,eAAe,kBAAkB,gBAAgB,gBAAgB,mBAAmB,UAAU,UAAU,iBAAiB;AAEvQ;","x_google_ignoreList":[0]}